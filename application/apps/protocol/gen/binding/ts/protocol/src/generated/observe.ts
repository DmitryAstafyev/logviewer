/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.27.2
 * source: observe.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from 'google-protobuf';
export namespace observe {
    export class ObserveOptions extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      origin: ObserveOrigin;
                      parser: ParserType;
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.origin = data.origin;
                this.parser = data.parser;
            }
        }
        get origin() {
            return pb_1.Message.getWrapperField(this, ObserveOrigin, 1) as ObserveOrigin;
        }
        set origin(value: ObserveOrigin) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_origin() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get parser() {
            return pb_1.Message.getWrapperField(this, ParserType, 2) as ParserType;
        }
        set parser(value: ParserType) {
            pb_1.Message.setWrapperField(this, 2, value);
        }
        get has_parser() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: {
            origin: ReturnType<typeof ObserveOrigin.prototype.toObject>;
            parser: ReturnType<typeof ParserType.prototype.toObject>;
        }): ObserveOptions {
            const message = new ObserveOptions({
                origin: ObserveOrigin.fromObject(data.origin),
                parser: ParserType.fromObject(data.parser),
            });
            return message;
        }
        toObject() {
            const data: {
                origin?: ReturnType<typeof ObserveOrigin.prototype.toObject>;
                parser?: ReturnType<typeof ParserType.prototype.toObject>;
            } = {};
            if (this.origin != null) {
                data.origin = this.origin.toObject();
            }
            if (this.parser != null) {
                data.parser = this.parser.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_origin)
                writer.writeMessage(1, this.origin, () => this.origin.serialize(writer));
            if (this.has_parser)
                writer.writeMessage(2, this.parser, () => this.parser.serialize(writer));
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ObserveOptions {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new ObserveOptions();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(
                            message.origin,
                            () => (message.origin = ObserveOrigin.deserialize(reader)),
                        );
                        break;
                    case 2:
                        reader.readMessage(
                            message.parser,
                            () => (message.parser = ParserType.deserialize(reader)),
                        );
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): ObserveOptions {
            return ObserveOptions.deserialize(bytes);
        }
    }
    export class DltParserSettings extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      filter_config: DltFilterConfig;
                      fibex_file_paths: string[];
                      with_storage_header: boolean;
                      tz: string;
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [2],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.filter_config = data.filter_config;
                this.fibex_file_paths = data.fibex_file_paths;
                this.with_storage_header = data.with_storage_header;
                this.tz = data.tz;
            }
        }
        get filter_config() {
            return pb_1.Message.getWrapperField(this, DltFilterConfig, 1) as DltFilterConfig;
        }
        set filter_config(value: DltFilterConfig) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_filter_config() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get fibex_file_paths() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set fibex_file_paths(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get with_storage_header() {
            return pb_1.Message.getField(this, 3) as boolean;
        }
        set with_storage_header(value: boolean) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_with_storage_header() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get tz() {
            return pb_1.Message.getField(this, 4) as string;
        }
        set tz(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_tz() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            filter_config: ReturnType<typeof DltFilterConfig.prototype.toObject>;
            fibex_file_paths: string[];
            with_storage_header: boolean;
            tz: string;
        }): DltParserSettings {
            const message = new DltParserSettings({
                filter_config: DltFilterConfig.fromObject(data.filter_config as any),
                fibex_file_paths: data.fibex_file_paths,
                with_storage_header: data.with_storage_header,
                tz: data.tz,
            });
            return message;
        }
        toObject() {
            const data: {
                filter_config?: ReturnType<typeof DltFilterConfig.prototype.toObject>;
                fibex_file_paths: string[];
                with_storage_header?: boolean;
                tz?: string;
            } = {
                fibex_file_paths: this.fibex_file_paths,
            };
            if (this.filter_config != null) {
                data.filter_config = this.filter_config.toObject();
            }
            if (this.with_storage_header != null) {
                data.with_storage_header = this.with_storage_header;
            }
            if (this.tz != null) {
                data.tz = this.tz;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_filter_config)
                writer.writeMessage(1, this.filter_config, () =>
                    this.filter_config.serialize(writer),
                );
            if (this.fibex_file_paths.length) writer.writeRepeatedString(2, this.fibex_file_paths);
            if (this.has_with_storage_header) writer.writeBool(3, this.with_storage_header);
            if (this.has_tz && this.tz.length) writer.writeString(4, this.tz);
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DltParserSettings {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new DltParserSettings();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(
                            message.filter_config,
                            () => (message.filter_config = DltFilterConfig.deserialize(reader)),
                        );
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        message.with_storage_header = reader.readBool();
                        break;
                    case 4:
                        message.tz = reader.readString();
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): DltParserSettings {
            return DltParserSettings.deserialize(bytes);
        }
    }
    export class DltFilterConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      min_log_level: number;
                      app_ids: string[];
                      ecu_ids: string[];
                      context_ids: string[];
                      app_id_count: number;
                      context_id_count: number;
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [2, 3, 4],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.min_log_level = data.min_log_level;
                this.app_ids = data.app_ids;
                this.ecu_ids = data.ecu_ids;
                this.context_ids = data.context_ids;
                this.app_id_count = data.app_id_count;
                this.context_id_count = data.context_id_count;
            }
        }
        get min_log_level() {
            return pb_1.Message.getField(this, 1) as number;
        }
        set min_log_level(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_min_log_level() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get app_ids() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set app_ids(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get ecu_ids() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set ecu_ids(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        get context_ids() {
            return pb_1.Message.getFieldWithDefault(this, 4, []) as string[];
        }
        set context_ids(value: string[]) {
            pb_1.Message.setField(this, 4, value);
        }
        get app_id_count() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set app_id_count(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_app_id_count() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get context_id_count() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set context_id_count(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get has_context_id_count() {
            return pb_1.Message.getField(this, 6) != null;
        }
        static fromObject(data: {
            min_log_level: number;
            app_ids: string[];
            ecu_ids: string[];
            context_ids: string[];
            app_id_count: number;
            context_id_count: number;
        }): DltFilterConfig {
            const message = new DltFilterConfig({
                min_log_level: data.min_log_level,
                app_ids: data.app_ids,
                ecu_ids: data.ecu_ids,
                context_ids: data.context_ids,
                app_id_count: data.app_id_count,
                context_id_count: data.context_id_count,
            });
            return message;
        }
        toObject() {
            const data: {
                min_log_level?: number;
                app_ids: string[];
                ecu_ids: string[];
                context_ids: string[];
                app_id_count?: number;
                context_id_count?: number;
            } = {
                app_ids: this.app_ids,
                ecu_ids: this.ecu_ids,
                context_ids: this.context_ids,
            };
            if (this.min_log_level != null) {
                data.min_log_level = this.min_log_level;
            }
            if (this.app_id_count != null) {
                data.app_id_count = this.app_id_count;
            }
            if (this.context_id_count != null) {
                data.context_id_count = this.context_id_count;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_min_log_level) writer.writeUint32(1, this.min_log_level);
            if (this.app_ids.length) writer.writeRepeatedString(2, this.app_ids);
            if (this.ecu_ids.length) writer.writeRepeatedString(3, this.ecu_ids);
            if (this.context_ids.length) writer.writeRepeatedString(4, this.context_ids);
            if (this.has_app_id_count) writer.writeInt64(5, this.app_id_count);
            if (this.has_context_id_count) writer.writeInt64(6, this.context_id_count);
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DltFilterConfig {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new DltFilterConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.min_log_level = reader.readUint32();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    case 4:
                        pb_1.Message.addToRepeatedField(message, 4, reader.readString());
                        break;
                    case 5:
                        message.app_id_count = reader.readInt64();
                        break;
                    case 6:
                        message.context_id_count = reader.readInt64();
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): DltFilterConfig {
            return DltFilterConfig.deserialize(bytes);
        }
    }
    export class SomeIpParserSettings extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      fibex_file_paths: string[];
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [1],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.fibex_file_paths = data.fibex_file_paths;
            }
        }
        get fibex_file_paths() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set fibex_file_paths(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: { fibex_file_paths: string[] }): SomeIpParserSettings {
            const message = new SomeIpParserSettings({
                fibex_file_paths: data.fibex_file_paths,
            });
            return message;
        }
        toObject() {
            const data: {
                fibex_file_paths: string[];
            } = {
                fibex_file_paths: this.fibex_file_paths,
            };
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.fibex_file_paths.length) writer.writeRepeatedString(1, this.fibex_file_paths);
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SomeIpParserSettings {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new SomeIpParserSettings();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): SomeIpParserSettings {
            return SomeIpParserSettings.deserialize(bytes);
        }
    }
    export class ProcessTransportConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      cwd: string;
                      command: string;
                      envs: Map<string, string>;
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.cwd = data.cwd;
                this.command = data.command;
                this.envs = data.envs;
            }
            if (!this.envs) this.envs = new Map();
        }
        get cwd() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set cwd(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_cwd() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get command() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set command(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_command() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get envs() {
            return pb_1.Message.getField(this, 3) as any as Map<string, string>;
        }
        set envs(value: Map<string, string>) {
            pb_1.Message.setField(this, 3, value as any);
        }
        static fromObject(data: {
            cwd: string;
            command: string;
            envs: {
                [key: string]: string;
            };
        }): ProcessTransportConfig {
            const message = new ProcessTransportConfig({
                cwd: data.cwd,
                command: data.command,
                envs: new Map(Object.entries(data.envs)),
            });
            return message;
        }
        toObject() {
            const data: {
                cwd?: string;
                command?: string;
                envs?: {
                    [key: string]: string;
                };
            } = {};
            if (this.cwd != null) {
                data.cwd = this.cwd;
            }
            if (this.command != null) {
                data.command = this.command;
            }
            if (this.envs != null) {
                data.envs = Object.fromEntries(this.envs);
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_cwd && this.cwd.length) writer.writeString(1, this.cwd);
            if (this.has_command && this.command.length) writer.writeString(2, this.command);
            for (const [key, value] of this.envs) {
                writer.writeMessage(3, this.envs, () => {
                    writer.writeString(1, key);
                    writer.writeString(2, value);
                });
            }
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProcessTransportConfig {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new ProcessTransportConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.cwd = reader.readString();
                        break;
                    case 2:
                        message.command = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message, () =>
                            pb_1.Map.deserializeBinary(
                                message.envs as any,
                                reader,
                                reader.readString,
                                reader.readString,
                            ),
                        );
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): ProcessTransportConfig {
            return ProcessTransportConfig.deserialize(bytes);
        }
    }
    export class SerialTransportConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      path: string;
                      baud_rate: number;
                      data_bits: number;
                      flow_control: number;
                      parity: number;
                      stop_bits: number;
                      send_data_delay: number;
                      exclusive: boolean;
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.path = data.path;
                this.baud_rate = data.baud_rate;
                this.data_bits = data.data_bits;
                this.flow_control = data.flow_control;
                this.parity = data.parity;
                this.stop_bits = data.stop_bits;
                this.send_data_delay = data.send_data_delay;
                this.exclusive = data.exclusive;
            }
        }
        get path() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set path(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_path() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get baud_rate() {
            return pb_1.Message.getField(this, 2) as number;
        }
        set baud_rate(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_baud_rate() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get data_bits() {
            return pb_1.Message.getField(this, 3) as number;
        }
        set data_bits(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get has_data_bits() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get flow_control() {
            return pb_1.Message.getField(this, 4) as number;
        }
        set flow_control(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        get has_flow_control() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get parity() {
            return pb_1.Message.getField(this, 5) as number;
        }
        set parity(value: number) {
            pb_1.Message.setField(this, 5, value);
        }
        get has_parity() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get stop_bits() {
            return pb_1.Message.getField(this, 6) as number;
        }
        set stop_bits(value: number) {
            pb_1.Message.setField(this, 6, value);
        }
        get has_stop_bits() {
            return pb_1.Message.getField(this, 6) != null;
        }
        get send_data_delay() {
            return pb_1.Message.getField(this, 7) as number;
        }
        set send_data_delay(value: number) {
            pb_1.Message.setField(this, 7, value);
        }
        get has_send_data_delay() {
            return pb_1.Message.getField(this, 7) != null;
        }
        get exclusive() {
            return pb_1.Message.getField(this, 8) as boolean;
        }
        set exclusive(value: boolean) {
            pb_1.Message.setField(this, 8, value);
        }
        get has_exclusive() {
            return pb_1.Message.getField(this, 8) != null;
        }
        static fromObject(data: {
            path: string;
            baud_rate: number;
            data_bits: number;
            flow_control: number;
            parity: number;
            stop_bits: number;
            send_data_delay: number;
            exclusive: boolean;
        }): SerialTransportConfig {
            const message = new SerialTransportConfig({
                path: data.path,
                baud_rate: data.baud_rate,
                data_bits: data.data_bits,
                flow_control: data.flow_control,
                parity: data.parity,
                stop_bits: data.stop_bits,
                send_data_delay: data.send_data_delay,
                exclusive: data.exclusive,
            });
            return message;
        }
        toObject() {
            const data: {
                path?: string;
                baud_rate?: number;
                data_bits?: number;
                flow_control?: number;
                parity?: number;
                stop_bits?: number;
                send_data_delay?: number;
                exclusive?: boolean;
            } = {};
            if (this.path != null) {
                data.path = this.path;
            }
            if (this.baud_rate != null) {
                data.baud_rate = this.baud_rate;
            }
            if (this.data_bits != null) {
                data.data_bits = this.data_bits;
            }
            if (this.flow_control != null) {
                data.flow_control = this.flow_control;
            }
            if (this.parity != null) {
                data.parity = this.parity;
            }
            if (this.stop_bits != null) {
                data.stop_bits = this.stop_bits;
            }
            if (this.send_data_delay != null) {
                data.send_data_delay = this.send_data_delay;
            }
            if (this.exclusive != null) {
                data.exclusive = this.exclusive;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_path && this.path.length) writer.writeString(1, this.path);
            if (this.has_baud_rate) writer.writeUint32(2, this.baud_rate);
            if (this.has_data_bits) writer.writeUint32(3, this.data_bits);
            if (this.has_flow_control) writer.writeUint32(4, this.flow_control);
            if (this.has_parity) writer.writeUint32(5, this.parity);
            if (this.has_stop_bits) writer.writeUint32(6, this.stop_bits);
            if (this.has_send_data_delay) writer.writeUint32(7, this.send_data_delay);
            if (this.has_exclusive) writer.writeBool(8, this.exclusive);
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): SerialTransportConfig {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new SerialTransportConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.path = reader.readString();
                        break;
                    case 2:
                        message.baud_rate = reader.readUint32();
                        break;
                    case 3:
                        message.data_bits = reader.readUint32();
                        break;
                    case 4:
                        message.flow_control = reader.readUint32();
                        break;
                    case 5:
                        message.parity = reader.readUint32();
                        break;
                    case 6:
                        message.stop_bits = reader.readUint32();
                        break;
                    case 7:
                        message.send_data_delay = reader.readUint32();
                        break;
                    case 8:
                        message.exclusive = reader.readBool();
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): SerialTransportConfig {
            return SerialTransportConfig.deserialize(bytes);
        }
    }
    export class TCPTransportConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      bind_addr: string;
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.bind_addr = data.bind_addr;
            }
        }
        get bind_addr() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set bind_addr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_bind_addr() {
            return pb_1.Message.getField(this, 1) != null;
        }
        static fromObject(data: { bind_addr: string }): TCPTransportConfig {
            const message = new TCPTransportConfig({
                bind_addr: data.bind_addr,
            });
            return message;
        }
        toObject() {
            const data: {
                bind_addr?: string;
            } = {};
            if (this.bind_addr != null) {
                data.bind_addr = this.bind_addr;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_bind_addr && this.bind_addr.length) writer.writeString(1, this.bind_addr);
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TCPTransportConfig {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new TCPTransportConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.bind_addr = reader.readString();
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): TCPTransportConfig {
            return TCPTransportConfig.deserialize(bytes);
        }
    }
    export class MulticastInfo extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      multiaddr: string;
                      interface: string;
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.multiaddr = data.multiaddr;
                this.interface = data.interface;
            }
        }
        get multiaddr() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set multiaddr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_multiaddr() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get interface() {
            return pb_1.Message.getField(this, 2) as string;
        }
        set interface(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get has_interface() {
            return pb_1.Message.getField(this, 2) != null;
        }
        static fromObject(data: { multiaddr: string; interface: string }): MulticastInfo {
            const message = new MulticastInfo({
                multiaddr: data.multiaddr,
                interface: data.interface,
            });
            return message;
        }
        toObject() {
            const data: {
                multiaddr?: string;
                interface?: string;
            } = {};
            if (this.multiaddr != null) {
                data.multiaddr = this.multiaddr;
            }
            if (this.interface != null) {
                data.interface = this.interface;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_multiaddr && this.multiaddr.length) writer.writeString(1, this.multiaddr);
            if (this.has_interface && this.interface.length) writer.writeString(2, this.interface);
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MulticastInfo {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new MulticastInfo();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.multiaddr = reader.readString();
                        break;
                    case 2:
                        message.interface = reader.readString();
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): MulticastInfo {
            return MulticastInfo.deserialize(bytes);
        }
    }
    export class UDPTransportConfig extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(
            data?:
                | any[]
                | {
                      bind_addr: string;
                      multicast: MulticastInfo[];
                  },
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [2],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                this.bind_addr = data.bind_addr;
                this.multicast = data.multicast;
            }
        }
        get bind_addr() {
            return pb_1.Message.getField(this, 1) as string;
        }
        set bind_addr(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        get has_bind_addr() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get multicast() {
            return pb_1.Message.getRepeatedWrapperField(this, MulticastInfo, 2) as MulticastInfo[];
        }
        set multicast(value: MulticastInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            bind_addr: string;
            multicast: ReturnType<typeof MulticastInfo.prototype.toObject>[];
        }): UDPTransportConfig {
            const message = new UDPTransportConfig({
                bind_addr: data.bind_addr,
                multicast: data.multicast.map((item) => MulticastInfo.fromObject(item as any)),
            });
            return message;
        }
        toObject() {
            const data: {
                bind_addr?: string;
                multicast?: ReturnType<typeof MulticastInfo.prototype.toObject>[];
            } = {};
            if (this.bind_addr != null) {
                data.bind_addr = this.bind_addr;
            }
            if (this.multicast != null) {
                data.multicast = this.multicast.map((item: MulticastInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_bind_addr && this.bind_addr.length) writer.writeString(1, this.bind_addr);
            if (this.multicast.length)
                writer.writeRepeatedMessage(2, this.multicast, (item: MulticastInfo) =>
                    item.serialize(writer),
                );
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): UDPTransportConfig {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new UDPTransportConfig();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.bind_addr = reader.readString();
                        break;
                    case 2:
                        reader.readMessage(message.multicast, () =>
                            pb_1.Message.addToRepeatedWrapperField(
                                message,
                                2,
                                MulticastInfo.deserialize(reader),
                                MulticastInfo,
                            ),
                        );
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): UDPTransportConfig {
            return UDPTransportConfig.deserialize(bytes);
        }
    }
    export class FileFormat extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {}) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
            }
        }
        static fromObject(data: {}): FileFormat {
            const message = new FileFormat({});
            return message;
        }
        toObject() {
            const data: {} = {};
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): FileFormat {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new FileFormat();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): FileFormat {
            return FileFormat.deserialize(bytes);
        }
    }
    export namespace FileFormat {
        export enum Type {
            PcapNG = 0,
            PcapLegacy = 1,
            Text = 2,
            Binary = 3,
        }
    }
    export class ParserType extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3]];
        constructor(
            data?:
                | any[]
                | ({} & (
                      | {
                            dlt?: DltParserSettings;
                            some_ip?: never;
                            text?: never;
                        }
                      | {
                            dlt?: never;
                            some_ip?: SomeIpParserSettings;
                            text?: never;
                        }
                      | {
                            dlt?: never;
                            some_ip?: never;
                            text?: boolean;
                        }
                  )),
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                if ('dlt' in data && data.dlt != undefined) {
                    this.dlt = data.dlt;
                }
                if ('some_ip' in data && data.some_ip != undefined) {
                    this.some_ip = data.some_ip;
                }
                if ('text' in data && data.text != undefined) {
                    this.text = data.text;
                }
            }
        }
        get dlt() {
            return pb_1.Message.getWrapperField(this, DltParserSettings, 1) as DltParserSettings;
        }
        set dlt(value: DltParserSettings) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_dlt() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get some_ip() {
            return pb_1.Message.getWrapperField(
                this,
                SomeIpParserSettings,
                2,
            ) as SomeIpParserSettings;
        }
        set some_ip(value: SomeIpParserSettings) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_some_ip() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get text() {
            return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
        }
        set text(value: boolean) {
            pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
        }
        get has_text() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get type() {
            const cases: {
                [index: number]: 'none' | 'dlt' | 'some_ip' | 'text';
            } = {
                0: 'none',
                1: 'dlt',
                2: 'some_ip',
                3: 'text',
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
        }
        static fromObject(data: {
            dlt?: ReturnType<typeof DltParserSettings.prototype.toObject>;
            some_ip?: ReturnType<typeof SomeIpParserSettings.prototype.toObject>;
            text?: boolean;
        }): ParserType {
            const message = new ParserType({});
            if (data.dlt != null) {
                message.dlt = DltParserSettings.fromObject(data.dlt as any);
            }
            if (data.some_ip != null) {
                message.some_ip = SomeIpParserSettings.fromObject(data.some_ip);
            }
            if (data.text != null) {
                message.text = data.text;
            }
            return message;
        }
        toObject() {
            const data: {
                dlt?: ReturnType<typeof DltParserSettings.prototype.toObject>;
                some_ip?: ReturnType<typeof SomeIpParserSettings.prototype.toObject>;
                text?: boolean;
            } = {};
            if (this.dlt != null) {
                data.dlt = this.dlt.toObject();
            }
            if (this.some_ip != null) {
                data.some_ip = this.some_ip.toObject();
            }
            if (this.text != null) {
                data.text = this.text;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_dlt) writer.writeMessage(1, this.dlt, () => this.dlt.serialize(writer));
            if (this.has_some_ip)
                writer.writeMessage(2, this.some_ip, () => this.some_ip.serialize(writer));
            if (this.has_text) writer.writeBool(3, this.text);
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ParserType {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new ParserType();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(
                            message.dlt,
                            () => (message.dlt = DltParserSettings.deserialize(reader)),
                        );
                        break;
                    case 2:
                        reader.readMessage(
                            message.some_ip,
                            () => (message.some_ip = SomeIpParserSettings.deserialize(reader)),
                        );
                        break;
                    case 3:
                        message.text = reader.readBool();
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): ParserType {
            return ParserType.deserialize(bytes);
        }
    }
    export class Transport extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3, 4]];
        constructor(
            data?:
                | any[]
                | ({} & (
                      | {
                            process?: ProcessTransportConfig;
                            tcp?: never;
                            udp?: never;
                            serial?: never;
                        }
                      | {
                            process?: never;
                            tcp?: TCPTransportConfig;
                            udp?: never;
                            serial?: never;
                        }
                      | {
                            process?: never;
                            tcp?: never;
                            udp?: UDPTransportConfig;
                            serial?: never;
                        }
                      | {
                            process?: never;
                            tcp?: never;
                            udp?: never;
                            serial?: SerialTransportConfig;
                        }
                  )),
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                if ('process' in data && data.process != undefined) {
                    this.process = data.process;
                }
                if ('tcp' in data && data.tcp != undefined) {
                    this.tcp = data.tcp;
                }
                if ('udp' in data && data.udp != undefined) {
                    this.udp = data.udp;
                }
                if ('serial' in data && data.serial != undefined) {
                    this.serial = data.serial;
                }
            }
        }
        get process() {
            return pb_1.Message.getWrapperField(
                this,
                ProcessTransportConfig,
                1,
            ) as ProcessTransportConfig;
        }
        set process(value: ProcessTransportConfig) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_process() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get tcp() {
            return pb_1.Message.getWrapperField(this, TCPTransportConfig, 2) as TCPTransportConfig;
        }
        set tcp(value: TCPTransportConfig) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_tcp() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get udp() {
            return pb_1.Message.getWrapperField(this, UDPTransportConfig, 3) as UDPTransportConfig;
        }
        set udp(value: UDPTransportConfig) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_udp() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get serial() {
            return pb_1.Message.getWrapperField(
                this,
                SerialTransportConfig,
                4,
            ) as SerialTransportConfig;
        }
        set serial(value: SerialTransportConfig) {
            pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
        }
        get has_serial() {
            return pb_1.Message.getField(this, 4) != null;
        }
        get transport() {
            const cases: {
                [index: number]: 'none' | 'process' | 'tcp' | 'udp' | 'serial';
            } = {
                0: 'none',
                1: 'process',
                2: 'tcp',
                3: 'udp',
                4: 'serial',
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3, 4])];
        }
        static fromObject(data: {
            process?: ReturnType<typeof ProcessTransportConfig.prototype.toObject>;
            tcp?: ReturnType<typeof TCPTransportConfig.prototype.toObject>;
            udp?: ReturnType<typeof UDPTransportConfig.prototype.toObject>;
            serial?: ReturnType<typeof SerialTransportConfig.prototype.toObject>;
        }): Transport {
            const message = new Transport({});
            if (data.process != null) {
                message.process = ProcessTransportConfig.fromObject(data.process as any);
            }
            if (data.tcp != null) {
                message.tcp = TCPTransportConfig.fromObject(data.tcp as any);
            }
            if (data.udp != null) {
                message.udp = UDPTransportConfig.fromObject(data.udp as any);
            }
            if (data.serial != null) {
                message.serial = SerialTransportConfig.fromObject(data.serial as any);
            }
            return message;
        }
        toObject() {
            const data: {
                process?: ReturnType<typeof ProcessTransportConfig.prototype.toObject>;
                tcp?: ReturnType<typeof TCPTransportConfig.prototype.toObject>;
                udp?: ReturnType<typeof UDPTransportConfig.prototype.toObject>;
                serial?: ReturnType<typeof SerialTransportConfig.prototype.toObject>;
            } = {};
            if (this.process != null) {
                data.process = this.process.toObject();
            }
            if (this.tcp != null) {
                data.tcp = this.tcp.toObject();
            }
            if (this.udp != null) {
                data.udp = this.udp.toObject();
            }
            if (this.serial != null) {
                data.serial = this.serial.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_process)
                writer.writeMessage(1, this.process, () => this.process.serialize(writer));
            if (this.has_tcp) writer.writeMessage(2, this.tcp, () => this.tcp.serialize(writer));
            if (this.has_udp) writer.writeMessage(3, this.udp, () => this.udp.serialize(writer));
            if (this.has_serial)
                writer.writeMessage(4, this.serial, () => this.serial.serialize(writer));
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Transport {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new Transport();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(
                            message.process,
                            () => (message.process = ProcessTransportConfig.deserialize(reader)),
                        );
                        break;
                    case 2:
                        reader.readMessage(
                            message.tcp,
                            () => (message.tcp = TCPTransportConfig.deserialize(reader)),
                        );
                        break;
                    case 3:
                        reader.readMessage(
                            message.udp,
                            () => (message.udp = UDPTransportConfig.deserialize(reader)),
                        );
                        break;
                    case 4:
                        reader.readMessage(
                            message.serial,
                            () => (message.serial = SerialTransportConfig.deserialize(reader)),
                        );
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): Transport {
            return Transport.deserialize(bytes);
        }
    }
    export class ObserveOrigin extends pb_1.Message {
        #one_of_decls: number[][] = [[1, 2, 3]];
        constructor(
            data?:
                | any[]
                | ({} & (
                      | {
                            file?: ObserveOrigin.File;
                            concat?: never;
                            stream?: never;
                        }
                      | {
                            file?: never;
                            concat?: ObserveOrigin.Concat;
                            stream?: never;
                        }
                      | {
                            file?: never;
                            concat?: never;
                            stream?: ObserveOrigin.Stream;
                        }
                  )),
        ) {
            super();
            pb_1.Message.initialize(
                this,
                Array.isArray(data) ? data : [],
                0,
                -1,
                [],
                this.#one_of_decls,
            );
            if (!Array.isArray(data) && typeof data == 'object') {
                if ('file' in data && data.file != undefined) {
                    this.file = data.file;
                }
                if ('concat' in data && data.concat != undefined) {
                    this.concat = data.concat;
                }
                if ('stream' in data && data.stream != undefined) {
                    this.stream = data.stream;
                }
            }
        }
        get file() {
            return pb_1.Message.getWrapperField(this, ObserveOrigin.File, 1) as ObserveOrigin.File;
        }
        set file(value: ObserveOrigin.File) {
            pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
        }
        get has_file() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get concat() {
            return pb_1.Message.getWrapperField(
                this,
                ObserveOrigin.Concat,
                2,
            ) as ObserveOrigin.Concat;
        }
        set concat(value: ObserveOrigin.Concat) {
            pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
        }
        get has_concat() {
            return pb_1.Message.getField(this, 2) != null;
        }
        get stream() {
            return pb_1.Message.getWrapperField(
                this,
                ObserveOrigin.Stream,
                3,
            ) as ObserveOrigin.Stream;
        }
        set stream(value: ObserveOrigin.Stream) {
            pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
        }
        get has_stream() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get origin() {
            const cases: {
                [index: number]: 'none' | 'file' | 'concat' | 'stream';
            } = {
                0: 'none',
                1: 'file',
                2: 'concat',
                3: 'stream',
            };
            return cases[pb_1.Message.computeOneofCase(this, [1, 2, 3])];
        }
        static fromObject(data: {
            file?: ReturnType<typeof ObserveOrigin.File.prototype.toObject>;
            concat?: ReturnType<typeof ObserveOrigin.Concat.prototype.toObject>;
            stream?: ReturnType<typeof ObserveOrigin.Stream.prototype.toObject>;
        }): ObserveOrigin {
            const message = new ObserveOrigin({});
            if (data.file != null) {
                message.file = ObserveOrigin.File.fromObject(data.file as any);
            }
            if (data.concat != null) {
                message.concat = ObserveOrigin.Concat.fromObject(data.concat as any);
            }
            if (data.stream != null) {
                message.stream = ObserveOrigin.Stream.fromObject(data.stream as any);
            }
            return message;
        }
        toObject() {
            const data: {
                file?: ReturnType<typeof ObserveOrigin.File.prototype.toObject>;
                concat?: ReturnType<typeof ObserveOrigin.Concat.prototype.toObject>;
                stream?: ReturnType<typeof ObserveOrigin.Stream.prototype.toObject>;
            } = {};
            if (this.file != null) {
                data.file = this.file.toObject();
            }
            if (this.concat != null) {
                data.concat = this.concat.toObject();
            }
            if (this.stream != null) {
                data.stream = this.stream.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_file) writer.writeMessage(1, this.file, () => this.file.serialize(writer));
            if (this.has_concat)
                writer.writeMessage(2, this.concat, () => this.concat.serialize(writer));
            if (this.has_stream)
                writer.writeMessage(3, this.stream, () => this.stream.serialize(writer));
            if (!w) return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ObserveOrigin {
            const reader =
                    bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                message = new ObserveOrigin();
            while (reader.nextField()) {
                if (reader.isEndGroup()) break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(
                            message.file,
                            () => (message.file = ObserveOrigin.File.deserialize(reader)),
                        );
                        break;
                    case 2:
                        reader.readMessage(
                            message.concat,
                            () => (message.concat = ObserveOrigin.Concat.deserialize(reader)),
                        );
                        break;
                    case 3:
                        reader.readMessage(
                            message.stream,
                            () => (message.stream = ObserveOrigin.Stream.deserialize(reader)),
                        );
                        break;
                    default:
                        reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static override deserializeBinary(bytes: Uint8Array): ObserveOrigin {
            return ObserveOrigin.deserialize(bytes);
        }
    }
    export namespace ObserveOrigin {
        export class File extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(
                data?:
                    | any[]
                    | {
                          name: string;
                          format: FileFormat.Type;
                          path: string;
                      },
            ) {
                super();
                pb_1.Message.initialize(
                    this,
                    Array.isArray(data) ? data : [],
                    0,
                    -1,
                    [],
                    this.#one_of_decls,
                );
                if (!Array.isArray(data) && typeof data == 'object') {
                    this.name = data.name;
                    this.format = data.format;
                    this.path = data.path;
                }
            }
            get name() {
                return pb_1.Message.getField(this, 1) as string;
            }
            set name(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_name() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get format() {
                return pb_1.Message.getField(this, 2) as FileFormat.Type;
            }
            set format(value: FileFormat.Type) {
                pb_1.Message.setField(this, 2, value);
            }
            get has_format() {
                return pb_1.Message.getField(this, 2) != null;
            }
            get path() {
                return pb_1.Message.getField(this, 3) as string;
            }
            set path(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            get has_path() {
                return pb_1.Message.getField(this, 3) != null;
            }
            static fromObject(data: { name: string; format: FileFormat.Type; path: string }): File {
                const message = new File({
                    name: data.name,
                    format: data.format,
                    path: data.path,
                });
                return message;
            }
            toObject() {
                const data: {
                    name?: string;
                    format?: FileFormat.Type;
                    path?: string;
                } = {};
                if (this.name != null) {
                    data.name = this.name;
                }
                if (this.format != null) {
                    data.format = this.format;
                }
                if (this.path != null) {
                    data.path = this.path;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_name && this.name.length) writer.writeString(1, this.name);
                if (this.has_format) writer.writeEnum(2, this.format);
                if (this.has_path && this.path.length) writer.writeString(3, this.path);
                if (!w) return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): File {
                const reader =
                        bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                    message = new File();
                while (reader.nextField()) {
                    if (reader.isEndGroup()) break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.name = reader.readString();
                            break;
                        case 2:
                            message.format = reader.readEnum();
                            break;
                        case 3:
                            message.path = reader.readString();
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): File {
                return File.deserialize(bytes);
            }
        }
        export class Concat extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(
                data?:
                    | any[]
                    | {
                          files: ObserveOrigin.File[];
                      },
            ) {
                super();
                pb_1.Message.initialize(
                    this,
                    Array.isArray(data) ? data : [],
                    0,
                    -1,
                    [1],
                    this.#one_of_decls,
                );
                if (!Array.isArray(data) && typeof data == 'object') {
                    this.files = data.files;
                }
            }
            get files() {
                return pb_1.Message.getRepeatedWrapperField(
                    this,
                    ObserveOrigin.File,
                    1,
                ) as ObserveOrigin.File[];
            }
            set files(value: ObserveOrigin.File[]) {
                pb_1.Message.setRepeatedWrapperField(this, 1, value);
            }
            static fromObject(data: {
                files: ReturnType<typeof ObserveOrigin.File.prototype.toObject>[];
            }): Concat {
                const message = new Concat({
                    files: data.files.map((item) => ObserveOrigin.File.fromObject(item as any)),
                });
                return message;
            }
            toObject() {
                const data: {
                    files?: ReturnType<typeof ObserveOrigin.File.prototype.toObject>[];
                } = {};
                if (this.files != null) {
                    data.files = this.files.map((item: ObserveOrigin.File) => item.toObject());
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.files.length)
                    writer.writeRepeatedMessage(1, this.files, (item: ObserveOrigin.File) =>
                        item.serialize(writer),
                    );
                if (!w) return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Concat {
                const reader =
                        bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                    message = new Concat();
                while (reader.nextField()) {
                    if (reader.isEndGroup()) break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.files, () =>
                                pb_1.Message.addToRepeatedWrapperField(
                                    message,
                                    1,
                                    ObserveOrigin.File.deserialize(reader),
                                    ObserveOrigin.File,
                                ),
                            );
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): Concat {
                return Concat.deserialize(bytes);
            }
        }
        export class Stream extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(
                data?:
                    | any[]
                    | {
                          name: string;
                          transport: Transport;
                      },
            ) {
                super();
                pb_1.Message.initialize(
                    this,
                    Array.isArray(data) ? data : [],
                    0,
                    -1,
                    [],
                    this.#one_of_decls,
                );
                if (!Array.isArray(data) && typeof data == 'object') {
                    this.name = data.name;
                    this.transport = data.transport;
                }
            }
            get name() {
                return pb_1.Message.getField(this, 1) as string;
            }
            set name(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get has_name() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get transport() {
                return pb_1.Message.getWrapperField(this, Transport, 2) as Transport;
            }
            set transport(value: Transport) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_transport() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                name: string;
                transport: ReturnType<typeof Transport.prototype.toObject>;
            }): Stream {
                const message = new Stream({
                    name: data.name,
                    transport: Transport.fromObject(data.transport),
                });
                return message;
            }
            toObject() {
                const data: {
                    name?: string;
                    transport?: ReturnType<typeof Transport.prototype.toObject>;
                } = {};
                if (this.name != null) {
                    data.name = this.name;
                }
                if (this.transport != null) {
                    data.transport = this.transport.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_name && this.name.length) writer.writeString(1, this.name);
                if (this.has_transport)
                    writer.writeMessage(2, this.transport, () => this.transport.serialize(writer));
                if (!w) return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Stream {
                const reader =
                        bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes),
                    message = new Stream();
                while (reader.nextField()) {
                    if (reader.isEndGroup()) break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.name = reader.readString();
                            break;
                        case 2:
                            reader.readMessage(
                                message.transport,
                                () => (message.transport = Transport.deserialize(reader)),
                            );
                            break;
                        default:
                            reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static override deserializeBinary(bytes: Uint8Array): Stream {
                return Stream.deserialize(bytes);
            }
        }
    }
}
